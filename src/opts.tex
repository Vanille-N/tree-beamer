\section{Optimizations}

\begin{frame}
    \frametitle{Some standard optimizations}
    \begin{tabular}{|l|c|c|l}
        Possible in...                     & SB     & TB \\
        Speculative read                   & \cmark & \cmark &\\
        Speculative write                  & \cmark & \xmark &\visible<2>{\(\gets\)}\\
        Redundant read                     & \cmark & \cmark &\\
        Redundant write                    & \cmark & \cmark &\\
        Read-Write reorder                 & \cmark & \xmark &\visible<2>{\(\gets\)}\\
        Read-Write reorder (fn args)       & \cmark & \cmark &\\
        Read-Read reorder                  & \xmark & \cmark &\visible<3>{\(\gets\)}\\
        Read-Read reorder (fn args)        & \cmark & \cmark &\\
        Write-Write reorder                & \cmark & \cmark &\\
        Write-Write reorder (fn args)      & \cmark & \cmark &\\
        Write-Read reorder                 & \cmark & \cmark &\\
        Write-Read reorder (fn args)       & \cmark & \cmark &\\
    \end{tabular}
    What is the cost of these extra optimizations ?
\end{frame}

\subsection{Possible optimizations}

\begin{frame}[fragile, t]
    \frametitle{{\cmark} Delay protected writes}
    \begin{onlyenv}<1-5>
        \begin{block}{}
            \begin{lstlisting}[language=rust, escapechar=@]
fn write(x: &mut u64) {
    x: [protected] Reserved
    *x = 42; // x: [protected] Active (optimization: move down ?)
    opaque(); // maybe foreign read/write

}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}
    \begin{onlyenv}<6->
        \begin{block}{}
            \begin{lstlisting}[language=rust, escapechar=@]
fn write(x: &mut u64) {
    // x: [protected] Reserved

    opaque(); // guaranteed no foreign read/write
    *x = 42; x: [protected] Active
}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<1-5>
        \begin{block}{}
            \begin{tikzpicture}[
                every node/.append style = {anchor = west},
                grow via three points={one child at (0.3,-0.5) and two children at (0.3,-0.5) and (0.3,-1.0)},
                edge from parent path={(\tikzparentnode\tikzparentanchor) |- (\tikzchildnode\tikzchildanchor)}
                ]
                \node (nparent) at (0,0) {\texttt{?}}
                    child {node (nx) {\texttt{x:}}};

                \node<2>[right = 0cm of nx, anchor=west] {[protected] \texttt{Reserved}};
                \node<3>[right = 0cm of nx, anchor=west] {[protected] \texttt{Active}};
                \node<4>[right = 0cm of nx, anchor=west] {[protected] \texttt{Active} | \texttt{Frozen} | \texttt{Disabled}};
                \node<5>[right = 0cm of nx, anchor=west] {[protected] \texttt{Active} | \cancel{\texttt{Frozen}} | \cancel{\texttt{Disabled}}};

                \node (vert) at (7,0 |- nparent) {};
                \node<3>[anchor=west] at (vert |- nx) {\(\gets\) write};
                \node<4>[anchor=west] at (vert |- nparent) {\(\gets\) ?};
            \end{tikzpicture}
        \end{block}
    \end{onlyenv}
\end{frame}

\begin{frame}[fragile, t]
    \frametitle{{\cmark} Speculative read}
    \begin{onlyenv}<1-2>
        \begin{block}{}
            \begin{lstlisting}[language=rust]
fn sum_while(incr: &u64) -> u64 {
    let mut sum = 0;
    // incr: [protected] Frozen
    while condition() { // maybe foreign read/write
        sum += *incr; // incr: [protected] Frozen|Disabled (optimization: move up ?)
        // UB if Disabled
    }
    sum
}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<3>
        \begin{block}{}
            \begin{lstlisting}[language=rust]
fn sum_while(incr: &u64) -> u64 {
    let mut sum = 0;
    let incr = *incr; // incr: [protected] Frozen
    while condition() { // guaranteed no foreign read/write
        sum += incr;
    }
    sum
}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}
\end{frame}

\subsection{Impossible optimizations}

\begin{frame}[fragile, t]
    \frametitle{Speculative writes}

    \begin{exampleblock}{Possible strengthening}
        Write to mutable references on function entry.
    \end{exampleblock}

    \begin{onlyenv}<1>
        \begin{block}{{\xmark} Speculative writes}
            \begin{lstlisting}[language=rust, basicstyle=\ttfamily\scriptsize]
fn foo(x: &mut u64) {
    // x: [protected] Reserved|Frozen


    maybe_nonterminating(); // maybe foreign read/write
    // x: [protected] Reserved|Frozen|Disabled
    *x = 42;
    // UB if x is Disabled
    // UB if x is Frozen AND maybe_nonterminating terminates
}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<2>
        \begin{block}{{\cmark} Speculative writes: strengthened model}
            \begin{lstlisting}[language=rust, basicstyle=\ttfamily\scriptsize]
fn foo(x: &mut u64) {
    // x: [protected] Active

    maybe_nonterminating(); // maybe foreign read/write
    // x: [protected] Active|Frozen|Disabled
    // UB if x is Frozen or Disabled, thus x: [protected] Active
    *x = 42; // x: [protected] Active
}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<3>
        \begin{block}{{\cmark} Speculative writes: strengthened model}
            \begin{lstlisting}[language=rust, basicstyle=\ttfamily\scriptsize]
fn foo(x: &mut u64) {
    // x: [protected] Active
    *x = 42; // x: [protected] Active
    maybe_nonterminating(); // maybe foreign read/write
    // x: [protected] Active|Frozen|Disabled, UB if Frozen|Disabled, thus x: [protected] Active

}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<4>
        \begin{block}{{\cmark} ``\texttt{as\_mut\_ptr}'' pattern}
            \begin{lstlisting}[language=rust, basicstyle=\ttfamily\scriptsize]
BCryptGenRandom(
    handle,
    // as_mut_ptr: &mut T -> *mut T
    buffer.as_mut_ptr(), // creates anonymous1: Reserved
    buffer.len() as ULONG, // creates anonymous2: Frozen, anonymous1 stays Reserved (foreign read)
    opts,
) // function entry: anonymous1 is still Reserved
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<5>
        \begin{block}{{\xmark} ``\texttt{as\_mut\_ptr}'' pattern: strengthened model}
            \begin{lstlisting}[language=rust, basicstyle=\ttfamily\scriptsize]
BCryptGenRandom(
    handle,
    // as_mut_ptr: &mut T -> *mut T
    buffer.as_mut_ptr(), // creates anonymous1: Active
    buffer.len() as ULONG, // creates anonymous2: Frozen, anonymous1 becomes Frozen (foreign read)
    opts,
) // function entry: anonymous1 is Frozen -> UB
            \end{lstlisting}
        \end{block}
    \end{onlyenv}
\end{frame}

\begin{frame}[fragile, t]
    \frametitle{Read-Write reorderings}
%%% possible
    \begin{exampleblock}{Possible strengthening}
        Foreign read makes \texttt{Active} become \texttt{Disabled}
        (rather than \texttt{Frozen})
    \end{exampleblock}


    \begin{onlyenv}<1>
        \begin{block}{{\xmark} Delay arbitrary writes towards reads}
            \begin{lstlisting}[language=rust, basicstyle=\ttfamily\scriptsize]
let x = &mut *y; // x: Reserved
*x = 42; // x: Active (optimization: move down ?)
opaque(); // x: Active|Frozen|Disabled (maybe foreign read/write)

let _ = *x; // UB if x is Disabled, thus x: Active|Frozen
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<2>
        \begin{errorblock}{{\cmark} Delay arbitrary writes towards reads: strengthened model}
            \begin{lstlisting}[language=rust, basicstyle=\ttfamily\scriptsize]
let x = &mut *y; // x: Reserved
*x = 42; // x: Active (optimization: move down ?)
opaque(); // x: Active|Disabled (maybe foreign read/write)

let _ = *x; // UB if x is Disabled, thus x:Active
            \end{lstlisting}
        \end{exampleblock}
    \end{onlyenv}

    \begin{onlyenv}<3>
        \begin{errorblock}{{\cmark} Delay arbitrary writes towards reads: strengthened model}
            \begin{lstlisting}[language=rust, basicstyle=\ttfamily\scriptsize]
let x = &mut *y;

opaque(); // Known not to read or write to `*x`
*x = 42;
let _ = *x;
            \end{lstlisting}
        \end{exampleblock}
    \end{onlyenv}

%%% impossible

    \begin{onlyenv}<4>
        \begin{block}{{\cmark} Arbitrary read reordering}
            \begin{lstlisting}[language=rust]
let x = &mut *z; // x: Reserved
*x = 42; // x: Active
let _ = *x; // x: Active (optimization: move down ?)
let _ = *z; // x: Frozen (foreign read)

            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<5>
        \begin{block}{{\cmark} Arbitrary read reordering}
            \begin{lstlisting}[language=rust]
let x = &mut *z; // x: Reserved
*x = 42; // x: Active

let _ = *z; // x: Frozen (foreign read)
let _ = *x; // x: Frozen
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<4>
        \begin{errorblock}{{\xmark} Arbitrary read reordering: strengthened model}
            \begin{lstlisting}[language=rust]
let x = &mut *z; // x: Reserved
*x = 42; // x: Active
let _ = *x; // x: Active (optimization: move down ?)
let _ = *z; // x: Disabled (foreign read)

            \end{lstlisting}
        \end{errorblock}
    \end{onlyenv}

    \begin{onlyenv}<5>
        \begin{errorblock}{{\xmark} Arbitrary read reordering: strengthened model}
            \begin{lstlisting}[language=rust]
let x = &mut *z; // x: Reserved
*x = 42; // x: Active

let _ = *z; // x: Disabled (foreign read)
let _ = *x; // Access through Disabled: UB!
            \end{lstlisting}
        \end{errorblock}
    \end{onlyenv}
\end{frame}

\begin{frame}
    \frametitle{Summary}
    \begin{itemize}
        \item read reorderings, spurious reads are possible
        \item spurious writes and unprotected write reorderings are not
        \item the model can be strengthened to justify stronger optimizations for
            writes, but at the cost of commonly written patterns and some read-read reorderings
    \end{itemize}
\end{frame}
