\begin{frame}
    \titlepage
\end{frame}

\section{Introduction}

\begin{frame}[fragile,t]
    \frametitle{Why have UB?}
    \framesubtitle{A simple(r) example}

    \begin{lstlisting}[language=rust]
enum bool {
    true = 1,
    false = 0,
}
    \end{lstlisting}

    \begin{onlyenv}<2>
        What happens if...
        \begin{lstlisting}[language=rust]
let b: bool = 2;
        \end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<3>
        What happens if...
        \begin{lstlisting}[language=rust]
let b: bool = unsafe { std::mem::transmute(2) };
//             ^^^^^^ remember this
let notb = !b; // ?
let notnotb = !notb;
assert!(b == notnotb); // ???
        \end{lstlisting}
        Can the compiler optimize a double negation into the identity ?
    \end{onlyenv}

    \begin{onlyenv}<4>
        What happens if...
        \begin{lstlisting}[language=rust, escapechar=@]
let b: bool = unsafe { std::mem::transmute(2) };
// UB: invalid value
@@
@@
@@
        \end{lstlisting}
        The compiler \textit{can} optimize a double negation into the identity.\\
        The compiler can do \textit{anything} once you have constructed an invalid value.
    \end{onlyenv}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Rust's type system}
    \begin{onlyenv}<1>
        \begin{lstlisting}[language=rust]
let t: T = v;
//          ^ value
//      ^ type
//  ^ variable
//  ^^^^^^^^ variable binding

fn incr(n: u8) -> u8 {
    n + 1
}

fn main() {
    let n: u8 = 42;
    let m: u8 = incr(n);
    println!("{n} + 1 = {m}");
}
        \end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<2>
        \begin{lstlisting}[language=rust]
// Primitives
f32, f64, u8, i8, u16, i16, u32, i32,
u64, i64, u128, i128, usize, isize, bool
// Products
struct Point {
    x: f64,
    y: f64,
}
type Triplet = (f64, f64, usize);
type Array = [f64; 10];
// Sums
enum Shape {
    Circle(Point, f64),
    Square(Point, f64),
    Triangle([Point; 3]),
}
        \end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<3>
        \begin{lstlisting}[language=rust, escapechar=@]
// Smart pointers
Box<T>, Rc<T>, Arc<T>, Cow<T>

// Raw pointers
*const T
*mut T
// (*const T @\(\sqsubset\)@ *mut T)

// References
@@&'a T // shared and immutable
@@&'a mut T // unique and mutable
// (&'a T @\(\sqsubset\)@ &'a mut T)
// ('a @\(\subset\)@ 'b @\(\Rightarrow\)@ &'a T @\(\sqsubset\)@ &'b T)
// ('a @\(\subset\)@ 'b @\(\Rightarrow\)@ &'a mut T @\(\sqsubset\)@ &'b mut T)
        \end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<4>
        Just like
        \begin{lstlisting}[language=rust]
// x: &mut bool
*x = 4;
        \end{lstlisting}
        is a type error (mismatched types \texttt{bool} and \texttt{u8}),
        \begin{lstlisting}[language=rust]
// x: &u8
*x = 4;
        \end{lstlisting}
        is also a type error (\texttt{\&\_} does not support assignment),
        and so is
        \begin{lstlisting}[language=rust]
// n: u8
let p = (&mut n, &mut n);
        \end{lstlisting}
        (impossible to satisfy lifetime constraints).\\

        Mutability and uniqueness are part of the type!\\
        Can we exploit that?
    \end{onlyenv}

\end{frame}

\begin{frame}[fragile,t]
    \frametitle{What is \texttt{unsafe}?}
    The type system of Rust is a bit too strict for some low-level applications.\\
    The \texttt{unsafe} keyword gives access to the language \textit{unsafe Rust},
    superset of Rust, where you can
    \begin{itemize}
        \item dereference raw pointers,
        \item call \texttt{unsafe} functions,
        \item do ffi.
    \end{itemize}

    This has the effect of making \texttt{unsafe} an escape hatch to locally bypass the type checker.
    \begin{exampleblock}{From the previous example}
        \texttt{std::mem::transmute} is an \texttt{unsafe} function, thus the
        use of \texttt{unsafe \{ std::mem::transmute(2) \}}.
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile, t]
    \frametitle{A motivating example for Aliasing UB}
    \begin{lstlisting}[language=rust]
fn foo(x: &mut u64) {
    let val = *x;
    opaque();
    *x = val;
}
    \end{lstlisting}
    optimized into
    \begin{lstlisting}[language=rust]
fn foo(x: &mut u64) {
    opaque();
}
    \end{lstlisting}
    Well-typedness of any program that calls \texttt{foo} implies uniqueness
    of \texttt{x} during the execution of \texttt{foo}: \texttt{opaque} cannot mutate \texttt{x}!\\
    \begin{onlyenv}<2->
    ...except if the user uses \texttt{unsafe} to bypass the uniqueness check\\
    \end{onlyenv}
    \begin{onlyenv}<3>
    ...which we are going to assume does not happen: we will declare it to be UB
    to use \texttt{unsafe} to violate the requirement of uniqueness on mutable references.
    \end{onlyenv}
\end{frame}

\begin{frame}[t]
    \frametitle{Tree Borrows: specification and detection of pointer aliasing UB}
    \begin{alertblock}{Starting observation}
        Proper usage of pointers (lifetime inclusion and inheritance of mutability) follows a tree discipline.
    \end{alertblock}
    \begin{block}{Key ideas}
        \begin{itemize}
            \item per-location tracking of pointers
            \item use a tree to store pointer identifiers
            \item on each reborrow a new identifier is added as a leaf of the tree
            \item each pointer has permissions
            \item a pointer can be used if its permission allows it (to be defined)
            \item using a pointer makes incompatible (to be defined) pointers lose permissions
        \end{itemize}
    \end{block}
\end{frame}

