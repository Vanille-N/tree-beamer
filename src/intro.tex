\begin{frame}
    \titlepage
\end{frame}

\section{Introduction}

% FIXME: explain why the tree is structural; provide intuition why it's also the good structure

\begin{frame}[fragile, t]
    \frametitle{What is Undefined Behavior ?}

    \begin{onlyenv}<1>
        Common pattern:
        \begin{itemize}
            \item for expressivity and performance the language introduces low level primitives \\
                (\texttt{std::mem::transmute}, pointer arithmetic, \texttt{Obj.magic}, ...),
            \item misuse of these primitives can interfere with compiler invariants \\
                (garbage collection, well-formedness of typed values, uniqueness, ...),
            \item guaranteeing deterministic behavior is
                \begin{itemize}
                    \item too expensive
                        (runtime bounds checks, type markers, ...)
                    \item not feasible
                        (undecidable at compile time)
                    \item or otherwise undesirable
                        (wasted optimization potential)
                \end{itemize}
        \end{itemize}
    \end{onlyenv}

    \begin{onlyenv}<2>
        \begin{alertblock}{Solution}
            Make it UB to misuse these constructs.\\
            If a compiler invariant is violated by a language primitive, the compiler can do literally anything.
        \end{alertblock}
        \begin{block}{UB as a contract}
            Deal between the programmer and the compiler: these primitives are
            dangerous, only use them if you really know what you are doing.
        \end{block}
        \begin{exampleblock}{\texttt{unsafe}}
            A selling point of Rust: \texttt{unsafe} is explicit.\\
            UB can only occur as a result of well-delimited blocks.
        \end{exampleblock}
    \end{onlyenv}
\end{frame}

\begin{frame}[fragile, t]
    \frametitle{Is \texttt{\&mut} really unique ?}
    \begin{lstlisting}[language=rust]
let data: u64 = 0;
let r0: &mut u64 = &mut x;

let x: &mut u64 = unsafe { &mut *(r0 as *mut u64) };
let y: &mut u64 = unsafe { &mut *(r0 as *mut u64) };
*x += 1;
*y += 1;
    \end{lstlisting}
    Clearly \texttt{x} and \texttt{y} alias, even though they
    are both unrelated \texttt{\&mut}.

    \begin{onlyenv}<2->
        \begin{block}{\texttt{unsafe} can violate compiler invariants}
            \texttt{unsafe} code can violate uniqueness (and well-formedness)
            guarantees, so the compiler cannot rely on them for optimizations.
        \end{block}
    \end{onlyenv}
\end{frame}

\begin{frame}[fragile, t]
    \frametitle{A motivating example for Aliasing UB}
    \begin{lstlisting}[language=rust]
fn foo(x: &mut u64) {
    let val = *x;
    *x = 42;
    opaque();
    *x = val;
}
    \end{lstlisting}
    optimized into
    \begin{lstlisting}[language=rust]
fn foo(x: &mut u64) {
    opaque();
}
    \end{lstlisting}
    Well-typedness of any program that calls \texttt{foo} implies uniqueness
    of \texttt{x} during the execution of \texttt{foo}: \texttt{opaque} cannot mutate \texttt{x}!\\
    \begin{onlyenv}<2->
    ...except if the user uses \texttt{unsafe} to violate uniqueness \\
    \end{onlyenv}
    \begin{onlyenv}<3>
    ...which we are going to assume does not happen: violating uniqueness is UB!
    \end{onlyenv}
\end{frame}

\begin{frame}[t]
    \frametitle{Tree Borrows: specification and detection of pointer aliasing UB}
    \begin{alertblock}{Starting observation}
        Proper usage of pointers (lifetime inclusion and inheritance of mutability) follows a tree discipline.
        \begin{itemize}
            \item when pointer dies, so do its children
            \item when pointer requires uniqueness, remove other branches
        \end{itemize}
    \end{alertblock}
    \begin{block}{Key ideas}
        \begin{itemize}
            \item per-location tracking of pointers
            \item each pointer has permissions
            \item on each reborrow a new identifier is added as a leaf of the tree
            \item a pointer can be used if its permission allows it (to be defined)
            \item using a pointer kills incompatible (to be defined) pointers
        \end{itemize}
    \end{block}
\end{frame}

