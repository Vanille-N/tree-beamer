\begin{frame}
    \titlepage
\end{frame}

\section{Introduction}

% FIXME:
% * SB is more strict in what way? can you give an example of what the limitations are?
% * better highlighting of marked lines
% maybe put a demo of the miri impl somewhere? that might also be good to show some of the examples/ motivate features.
% The new contribution of SB is unclear
% define "UB" = Undefined Behavior
% impossible to reorder reads. does the compiler reorder reads ? Is compiler + SB unsound ?
% flip around the patterns vs opts tradeoff: we need this pattern so we cannot have this optimization
% what is miri ? Say that it does not change the type system but checks its guarantees.
% UB vs unsound, who is at fault ?
% tradeoff between optimizations and UB more explicit
% explain why the tree is structural; provide intuition why it's also the good structure
% fit state transition system at each step of the model somehow ?
% more annotations in code examples
% better explanation of what the comparison to the borchk means; less fixing show model that works
% replace "need fixing" to say explicitly that it is the object of the two following subsections
% be clearer what is the version of the model at all times

\begin{frame}[fragile,t]
    \frametitle{A motivating example}
    See code example: \texttt{demo}
\end{frame}

\begin{frame}
    \frametitle{Is my optimization unsound ?\\No, it's the client that is UB.}
    UB: ``Undefined Behavior''
    \begin{itemize}
        \item the semantics of a program that contains UB are undefined: any behavior can occur
        \item equivalently: the compiler can assume that UB does not occur
    \end{itemize}
    The compiler is allowed to ``miscompile'' programs that contain UB.\\

    In this case: pointer aliasing UB.\\
    (Other kinds: uninitialized memory, data races, dangling pointers, ...)
\end{frame}

\begin{frame}
    \frametitle{The role of pointer aliasing UB}
    (Tree|Stacked) Borrows
    \begin{itemize}
        \item define an aliasing discipline
        \item detect violations of this discipline
    \end{itemize}
    in order to
    \begin{itemize}
        \item enable compiler optimizations by ruling out aliasing patterns
            \begin{itemize}
                \item remove redundant loads and stores
                \item permute noninterfering operations
            \end{itemize}
        \item hint at bugs in \texttt{unsafe} code
        \item justify LLVM attributes on pointers that \texttt{rustc} emits
            (\texttt{noalias} and \texttt{dereferenceable} require their own
            additional aliasing guarantees and enable corresponding optimizations)
    \end{itemize}~\\
\end{frame}

\begin{frame}[fragile]
    \frametitle{Motivating example: with Miri}
    Miri (\href{https://github.com/rust-lang/miri}{\texttt{github:rust-lang/miri}}) is
    \begin{itemize}
        \item a Rust interpreter
        \item that detects UB
    \end{itemize}~\\

    Back to \texttt{demo}: run with Miri
\end{frame}

\begin{frame}
    \frametitle{Basics of Stacked Borrows (SB)}
    \begin{block}{Starting observation}
        Proper usage of mutable references follows a stack discipline.
    \end{block}
    \begin{block}{Key ideas}
        \begin{itemize}
            \item per-location tracking of pointers (with improved allocation-level tracking)
            \item use a stack to store pointer identifiers
            \item on each reborrow a new identifier is pushed to the stack
            \item a pointer can be used if its identifier is in the stack
            \item using of a pointer pops everything above it (more recent)
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{An example SB execution}
\end{frame}

\begin{frame}
    \frametitle{SB too strict ?}
    % TODO
    % mention tradeoff here
\end{frame}

\begin{frame}[t]
    \frametitle{\cancel{Stacked} Tree Borrows (TB)}
    \begin{onlyenv}<1>
        \begin{block}{Starting observation}
            Proper usage of mutable references follows a stack discipline.
        \end{block}
        \begin{block}{Key ideas}
            \begin{itemize}
                \item per-location tracking of pointers
                \item use a stack to store pointer identifiers
                \item on each reborrow a new identifier is pushed to the top of the stack
                \item a pointer can be used if its identifier is in the stack
                \item using of a pointer pops everything above it (more recent)
            \end{itemize}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<2>
        \begin{block}{Starting observation}
            Proper usage of {\color{red}all pointers} follows a {\color{red}tree} discipline.
        \end{block}
        \begin{block}{Key ideas}
            \begin{itemize}
                \item per-location tracking of pointers
                \item use a {\color{red}tree} to store pointer identifiers
                \item on each reborrow a new identifier is {\color{red}added as a leaf of the tree}
                \item \cancel{a pointer can be used if its identifier is in the stack}
                \item \cancel{using of a pointer pops everything above it (more recent)}
                \item each pointer has permissions
                \item a pointer can be used if its permission allows it (to be defined)
                \item using a pointer makes incompatible (to be defined) pointers lose permissions
            \end{itemize}
        \end{block}
    \end{onlyenv}
\end{frame}

