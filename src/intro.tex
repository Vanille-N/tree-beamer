\begin{frame}
    \titlepage
\end{frame}

\section{Introduction}

\begin{frame}[fragile,t]
    \frametitle{A motivating example}
    \begin{onlyenv}<1-2>
        \begin{block}{}
            \begin{minipage}{\textwidth}
                \begin{lstlisting}[language=rust, escapechar=@]
@ @/// What does this do ?
@ @fn foo(x: &mut u64) {
@ @   let val1 = *x;
@ @   opaque();
@ @   let val2 = *x;
@\visible<2>{>}@   *x = val1;
@ @   opaque();
@ @   *x = val2;
@ @}
                \end{lstlisting}
            \end{minipage}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<3-4>
        \begin{block}{}
            \begin{minipage}{\textwidth}
                \begin{lstlisting}[language=rust, escapechar=@]
@ @/// What does this do ?
@ @fn foo(x: &mut u64) {
@\visible<4>{>}@   let val1 = *x;
@ @   opaque();
@ @   let val2 = *x;
@ @
@ @   opaque();
@ @   *x = val2;
@ @}
                \end{lstlisting}
            \end{minipage}
        \end{block}
        \begin{block}{Assumptions}
            \texttt{opaque} does not read from \texttt{*x}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<5-6>
        \begin{block}{}
            \begin{minipage}{\textwidth}
                \begin{lstlisting}[language=rust, escapechar=@]
@ @/// What does this do ?
@ @fn foo(x: &mut u64) {
@ @
@ @   opaque();
@\visible<6>{>}@   let val2 = *x;
@ @
@ @   opaque();
@\visible<6>{>}@   *x = val2;
@ @}
                \end{lstlisting}
            \end{minipage}
        \end{block}
        \begin{block}{Assumptions}
            \texttt{opaque} does not read from or write to \texttt{*x}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<7>
        \begin{block}{}
            \begin{minipage}{\textwidth}
                \begin{lstlisting}[language=rust, escapechar=@]
@ @/// Calls opaque twice, does not modify the argument.
@ @fn foo(x: &mut u64) {
@ @
@ @   opaque();
@ @
@ @
@ @   opaque();
@ @
@ @}
                \end{lstlisting}
            \end{minipage}
        \end{block}
        \begin{block}{Assumptions}
            \texttt{opaque} does not read from or write to \texttt{*x}
        \end{block}
    \end{onlyenv}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Aliasing assumptions are easy to break}
    \begin{onlyenv}<1>
        \begin{block}{}
            \begin{lstlisting}[language=rust, escapechar=@]






@ @fn main() {
@ @   let mut x = 0;
@ @   let rmut = &mut x;
@ @
@ @
@ @   const VAL: u64 = 42;
@ @   *rmut = VAL;
@ @   foo(&mut *rmut); // Shoul be a noop, right ?
@ @   assert_eq!(*rmut, VAL);
@ @}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}

    \begin{onlyenv}<2-4>
        \begin{block}{}
            \begin{lstlisting}[language=rust, escapechar=@]
@ @static mut PTR: Option<*mut u64> = None;
@ @fn opaque() { unsafe {
@ @    if let Some(ptr) = PTR {
@\visible<4>{>}@        *ptr = 31;
@ @    }
@ @} }
@ @fn main() {
@ @   let mut x = 0;
@ @   let rmut = &mut x;
@\visible<3>{>}@   unsafe { PTR = Some(rmut as *mut u64); }
@ @
@ @   const VAL: u64 = 42;
@ @   *rmut = VAL;
@ @   foo(&mut *rmut); // Shoul be a noop, right ?
@ @   assert_eq!(*rmut, VAL); // Panic !?
@ @}
            \end{lstlisting}
        \end{block}
    \end{onlyenv}
\end{frame}

\begin{frame}
    \frametitle{Is my optimization unsound ?\\No, it's the client that is UB.}
    In this case: pointer aliasing UB.

    \begin{itemize}
        \item enable optimizations by ruling out aliasing patterns
        \item justify LLVM attributes on pointers
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{What Tree Borrows thinks of the previous example}
    \texttt{\$ MIRIFLAGS=-Zmiri-tree-borrows cargo +miri miri run}
        \begin{lstlisting}
error: Undefined Behavior:
  --> src/example.rs
   |
   |         *ptr = 31;
   |         ^^^^^^^^^ write access is forbidden
   |
   [...]

  --> src/example.rs
   |
   | fn foo(x: &mut u64) {
   |         ^
   |
   [...]
        \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{(Tree|Stacked) Borrows}
    \begin{itemize}
        \item SB predates TB: design of TB inspired by shortcomings of SB
        \item similar enough interface for them to coexist in \texttt{miri}\\
            (switch: \texttt{MIRIFLAGS+=" -Zmiri-tree-borrows"})
            \begin{minipage}{0.9\textwidth}
            \begin{block}{}
                \begin{lstlisting}[language=rust, basicstyle=\ttfamily\fontsize{7}{8}\selectfont]
fn new_alloc(Size, MemoryKind) -> Self;
fn dealloc(&mut self, AllocRange, Provenance) -> Result<()>;

fn read(&mut self, AllocRange, Provenance) -> Result<()>;
fn write(&mut self, AllocRange, Provenance) -> Result<()>;

fn retag_ptr(&mut self, Provenance, RetagKind, Type) -> Result<Provenance>;
                \end{lstlisting}
            \end{block}
            \end{minipage}
    \end{itemize}
\end{frame}


