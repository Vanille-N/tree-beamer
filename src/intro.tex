\begin{frame}
    \titlepage
\end{frame}

\section{Introduction}

% FIXME: explain why the tree is structural; provide intuition why it's also the good structure

\begin{frame}
    \includegraphics[width=\textwidth]{ecosystem.pdf}
\end{frame}

%\begin{frame}[fragile,t]
%    \frametitle{What is UB?}
%    \begin{onlyenv}<1>
%        Undefined Behavior (UB) arises
%        \begin{itemize}
%            \item in languages that have both high- and low-level components\\
%                (C, C++, OCaml, Java, Rust: yes)\\
%                (Assembly, Python: no)
%            \item as a necessity from the existence of
%                \begin{itemize}
%                    \item functions that bypass type systems\\
%                        (\texttt{Obj.magic}, \texttt{std::mem::transmute}, \texttt{void*})
%                    \item unpredictable interaction between language primitives\\
%                        (multithreading, pointer arithmetic)
%                    \item interaction with other languages\\
%                        (FFI, inline assembly)
%                \end{itemize}
%        \end{itemize}~\\
%        Fundamental tradeoff: more UB = more optimizations = less predictability\\
%        Why not Stacked Borrows? Too much UB.\\
%        For Tree Borrows: try less UB, even at the cost of some optimizations.
%    \end{onlyenv}
%\end{frame}

\begin{frame}[fragile, t]
    \frametitle{Pointer types in Rust}
    \begin{onlyenv}<1>
        \begin{lstlisting}[language=rust, escapechar=@]
// Raw pointers (unsafe)
*const T
*mut T
// (*const T @\(\sqsubset\)@ *mut T)

// References (safe)
@@&'a T // shared and immutable
@@&'a mut T // unique and mutable
// (&'a T @\(\sqsubset\)@ &'a mut T)
// ('a @\(\subset\)@ 'b @\(\Rightarrow\)@ &'a T @\(\sqsubset\)@ &'b T)
// ('a @\(\subset\)@ 'b @\(\Rightarrow\)@ &'a mut T @\(\sqsubset\)@ &'b mut T)
        \end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<2>
        Just like
        \begin{lstlisting}[language=rust]
// x: &mut bool
*x = 4;
        \end{lstlisting}
        is a type error (mismatched types \texttt{bool} and \texttt{u8}),
        \begin{lstlisting}[language=rust]
// x: &u8
*x = 4;
        \end{lstlisting}
        is also a type error (\texttt{\&\_} does not support assignment),
        and so is
        \begin{lstlisting}[language=rust]
// n: u8
let p = (&mut n, &mut n);
        \end{lstlisting}
        (impossible to satisfy lifetime constraints).\\

        Mutability and uniqueness are part of the type!\\
        Can we exploit that?
    \end{onlyenv}
\end{frame}

\begin{frame}[fragile, t]
    \frametitle{Is \texttt{\&mut} really unique ?}
    \begin{lstlisting}[language=rust]
let data: u64 = 0;
let r0: &mut u64 = &mut x;

let x: &mut u64 = unsafe { &mut *(r0 as *mut u64) };
let y: &mut u64 = unsafe { &mut *(r0 as *mut u64) };
*x += 1;
*y += 1;
    \end{lstlisting}
    Clearly \texttt{x} and \texttt{y} alias, even though they
    are both unrelated \texttt{\&mut}.

    \begin{onlyenv}<2->
        \begin{block}{\texttt{unsafe} can violate compiler invariants}
            \texttt{unsafe} code can violate uniqueness (and well-formedness)
            guarantees, so the compiler cannot rely on them for optimizations.
        \end{block}
    \end{onlyenv}
\end{frame}

\begin{frame}[fragile, t]
    \frametitle{A motivating example for Aliasing UB}
    \begin{lstlisting}[language=rust]
fn foo(x: &mut u64) {
    let val = *x;
    *x = 42;
    opaque();
    *x = val;
}
    \end{lstlisting}
    optimized into
    \begin{lstlisting}[language=rust]
fn foo(x: &mut u64) {
    opaque();
}
    \end{lstlisting}
    Well-typedness of any program that calls \texttt{foo} implies uniqueness
    of \texttt{x} during the execution of \texttt{foo}: \texttt{opaque} cannot mutate \texttt{x}!\\
    \begin{onlyenv}<2->
    ...except if the user uses \texttt{unsafe} to violate uniqueness \\
    \end{onlyenv}
    \begin{onlyenv}<3>
    ...which we are going to assume does not happen: violating uniqueness is UB!
    \end{onlyenv}
\end{frame}

\begin{frame}[fragile, t]
    \frametitle{How much UB is enough ? Too much ?}
    \vspace{-1em}
    \begin{figure}
        \makebox[\textwidth][c]{
            \includegraphics[width=13cm]{how-much-ub.png}
        }
    \end{figure}
\end{frame}

\begin{frame}[t]
    \frametitle{Tree Borrows: specification and detection of pointer aliasing UB}
    \begin{alertblock}{Starting observation}
        Proper usage of pointers (lifetime inclusion and inheritance of mutability) follows a tree discipline.
        \begin{itemize}
            \item when pointer dies, so do its children
            \item when pointer requires uniqueness, remove branches
        \end{itemize}
    \end{alertblock}
    \begin{block}{Key ideas}
        \begin{itemize}
            \item per-location tracking of pointers
            \item each pointer has permissions
            \item on each reborrow a new identifier is added as a leaf of the tree
            \item a pointer can be used if its permission allows it (to be defined)
            \item using a pointer kills incompatible (to be defined) pointers
        \end{itemize}
    \end{block}
\end{frame}

