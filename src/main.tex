\documentclass[dvipsnames]{beamer}

\usepackage{currfile}
\usepackage{pgfpages}
% \setbeameroption{hide notes} % Only slides
% \setbeameroption{show only notes} % Only notes
% \setbeameroption{show notes on second screen=right} % Both
% \setbeamertemplate{note page}{\pagecolor{yellow!5}\insertnote}\usepackage{palatino}


\input{head-beamerpkg}
\input{head-extra}
\input{head-macros}

\title[TreeBor]{Tree Borrows}
\subtitle{An aliasing model for Rust}
\author{Neven \textsc{Villani}}
\date{Oct 2022 - Jun 2023\\at MPI-SWS Saarbr\"ucken}

\renewcommand{\familydefault}{\sfdefault}
\begin{document}

\input{intro}

% What structure do we want for the presentation ?
% In no particular order:
%[ ] - SB basics
%[ ]   - quick word on 2-phase borrows
%[X]   - same interface
%[X]   - stack structure and comparison of dimensions
%[ ] - comparison with SB
%[ ]   - are the lost optimizations important ?
%[ ]   - what more code can we write ?
%[ ]     - copy_nonoverlapping is a good selling point
%[X] - derivation of the tree structure
%[X]   - with things that should not change anything significant
%[X]     - `fn(&x) { x }` ~ `fn(&x) { &*x }`
%[X]     - `*_ = 1` ~ `*(&*_) = 1`
%        showing that it is basically mandatory that we only
%        distinguish between child vs self vs foreign,
%        then the lack of distinction between child and self is a choice,
%        not a necessity.
%[X]   - some freedom in when we create a new pointer:
%        it's easy to define "equivalence classes" of "this reference
%        and all its raw copies"
%[ ] - necessary rules
%[ ]   - noalias requirements
%[ ]   - unique path of Active
%[ ] - chosen rules
%[ ]   - Active -> Frozen
%[ ]   - everything starts Reserved
%[ ]   - not writing on function entry
%[ ]   for each of these show what we would lose/gain in terms of patterns/optimizations
%      if we changed them.
%[ ] - how to use / a working example
%[X]   - MIRIFLAGS
%[ ]   - interpretation of errors

\input{structure}

\input{rules}

\input{evaluation}

\end{document}
